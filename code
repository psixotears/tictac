package main

import (
	"log"
	"strconv"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

const (
	Empty  = 0
	Xnew   = 1
	Onew   = 2
	Xold   = 3
	Oold   = 4
)

// —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type GameState struct {
	Board       [3][3]int
	MovesXNew   []int
	MovesXOld   []int
	MovesONew   []int
	MovesOOld   []int
	CurrentMove int
	GameOver    bool
}

// –≥–ª–æ–±–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –∏–≥—Ä –ø–æ chatID
var games = make(map[int64]*GameState)

// —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—è
func renderBoard(game *GameState) string {
	result := ""
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			switch game.Board[i][j] {
			case Xnew:
				result += "X"
			case Onew:
				result += "O"
			case Xold:
				result += "(x)"
			case Oold:
				result += "(o)"
			default:
				result += "."
			}
		}
		result += "\n"
	}
	return result
}

// —á–µ–π —Ö–æ–¥
func currentStatus(game *GameState) string {
	if game.GameOver {
		return ""
	}
	if game.CurrentMove == Xnew {
		return "–•–æ–¥ X"
	}
	return "–•–æ–¥ O"
}

// –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã —Ç–æ–ª—å–∫–æ –ø–æ —Å–≤–µ–∂–∏–º —Ñ–∏–≥—É—Ä–∞–º
func checkWinner(game *GameState, val int) bool {
	for i := 0; i < 3; i++ {
		if game.Board[i][0] == val && game.Board[i][1] == val && game.Board[i][2] == val {
			return true
		}
		if game.Board[0][i] == val && game.Board[1][i] == val && game.Board[2][i] == val {
			return true
		}
	}
	if game.Board[0][0] == val && game.Board[1][1] == val && game.Board[2][2] == val {
		return true
	}
	if game.Board[0][2] == val && game.Board[1][1] == val && game.Board[2][0] == val {
		return true
	}
	return false
}

// –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ö–æ–¥–∞
func makeMove(game *GameState, cell int) string {
	if game.GameOver {
		return "–ò–≥—Ä–∞ —É–∂–µ –∑–∞–∫–æ–Ω—á–µ–Ω–∞!"
	}
	if cell < 0 || cell > 8 {
		return "–ù–µ–≤–µ—Ä–Ω–∞—è —è—á–µ–π–∫–∞!"
	}
	row, col := cell/3, cell%3
	if game.Board[row][col] != Empty {
		return "–≠—Ç–∞ –∫–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞!"
	}

	if game.CurrentMove == Xnew {
		game.Board[row][col] = Xnew
		game.MovesXNew = append(game.MovesXNew, cell)

		if checkWinner(game, Xnew) {
			game.GameOver = true
			return "–ü–æ–±–µ–¥–∏–ª X!"
		}

		if len(game.MovesXNew) >= 3 {
			old := game.MovesXNew[0]
			game.Board[old/3][old%3] = Xold
			game.MovesXOld = append(game.MovesXOld, old)
		}

		if len(game.MovesXOld) > 1 {
			remove := game.MovesXOld[0]
			game.MovesXOld = game.MovesXOld[1:]
			game.Board[remove/3][remove%3] = Empty
			game.MovesXNew = game.MovesXNew[1:]
		}

		game.CurrentMove = Onew
	} else {
		game.Board[row][col] = Onew
		game.MovesONew = append(game.MovesONew, cell)

		if checkWinner(game, Onew) {
			game.GameOver = true
			return "–ü–æ–±–µ–¥–∏–ª O!"
		}

		if len(game.MovesONew) >= 3 {
			old := game.MovesONew[0]
			game.Board[old/3][old%3] = Oold
			game.MovesOOld = append(game.MovesOOld, old)
		}

		if len(game.MovesOOld) > 1 {
			remove := game.MovesOOld[0]
			game.MovesOOld = game.MovesOOld[1:]
			game.Board[remove/3][remove%3] = Empty
			game.MovesONew = game.MovesONew[1:]
		}

		game.CurrentMove = Xnew
	}

	return ""
}

// —Å–±—Ä–æ—Å –∏–≥—Ä—ã
func resetBoard(game *GameState) {
	game.Board = [3][3]int{}
	game.MovesXNew = []int{}
	game.MovesXOld = []int{}
	game.MovesONew = []int{}
	game.MovesOOld = []int{}
	game.CurrentMove = Xnew
	game.GameOver = false
}

// –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
func boardKeyboard(game *GameState) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	if !game.GameOver {
		for i := 0; i < 3; i++ {
			var row []tgbotapi.InlineKeyboardButton
			for j := 0; j < 3; j++ {
				cell := i*3 + j
				text := "."
				switch game.Board[i][j] {
				case Xnew:
					text = "X"
				case Onew:
					text = "O"
				case Xold:
					text = "(x)"
				case Oold:
					text = "(o)"
				}
				row = append(row, tgbotapi.NewInlineKeyboardButtonData(text, strconv.Itoa(cell)))
			}
			rows = append(rows, row)
		}
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞", "reset"),
	))
	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

// –≥–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –±–æ—Ç–∞
func main() {
	bot, err := tgbotapi.NewBotAPI("YOUR_TOKEN_HERE")
	if err != nil {
		log.Panic(err)
	}

	bot.Debug = false
	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60
	updates := bot.GetUpdatesChan(u)

	for update := range updates {
		var chatID int64
		if update.Message != nil {
			chatID = update.Message.Chat.ID
		} else if update.CallbackQuery != nil {
			chatID = update.CallbackQuery.Message.Chat.ID
		} else {
			continue
		}

		// –ø–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º –∏–≥—Ä—É –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
		game, exists := games[chatID]
		if !exists {
			game = &GameState{}
			game.CurrentMove = Xnew
			games[chatID] = game
		}

		if update.Message != nil && update.Message.Text == "/start" {
			resetBoard(game)
			msg := tgbotapi.NewMessage(chatID, "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!\n"+renderBoard(game)+currentStatus(game))
			msg.ReplyMarkup = boardKeyboard(game)
			bot.Send(msg)
		}

		if update.CallbackQuery != nil {
			data := update.CallbackQuery.Data

			if data == "reset" {
				resetBoard(game)
				edit := tgbotapi.NewEditMessageTextAndMarkup(
					chatID,
					update.CallbackQuery.Message.MessageID,
					"–ù–æ–≤–∞—è –∏–≥—Ä–∞!\n"+renderBoard(game)+currentStatus(game),
					boardKeyboard(game),
				)
				bot.Send(edit)
				bot.Request(tgbotapi.NewCallback(update.CallbackQuery.ID, ""))
				continue
			}

			cell, _ := strconv.Atoi(data)
			result := makeMove(game, cell)
			text := renderBoard(game)
			if result != "" {
				text += "\n" + result
			} else {
				text += currentStatus(game)
			}

			edit := tgbotapi.NewEditMessageTextAndMarkup(
				chatID,
				update.CallbackQuery.Message.MessageID,
				text,
				boardKeyboard(game),
			)
			bot.Send(edit)
			bot.Request(tgbotapi.NewCallback(update.CallbackQuery.ID, ""))
		}
	}
}
